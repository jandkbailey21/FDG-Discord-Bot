Below is the **high-level system map** of how data moves through the FDG application (Sheets + Apps Script + Discord bot). I’m describing **architecture + flows only** (no fixes), treating formulas/tabs as part of the runtime. 

---

## System components and “source of truth” roles

### A) Google Sheet (the “database + UI”)

Key tabs (observed in the export):

* **Config (hidden):** event header ↔ registration URL list (drives event refresh).
* **MPO / FPO:** player master tables (Name, PDGA #, rankings, plus **event registration columns**). Also contains **Ownership** formula column.
* **DraftBoard:** baseline draft assignments (Team, Division, Player Name).
* **Transactions:** append-only ledger (Date, Type, Team, PDGA, Name, From, To, Notes).
* **Rosters:** computed “current ownership state” (Team ↔ PDGA ↔ Name ↔ Division). This is the **primary lookup table** for Ownership.
* **Team tabs (SIR/EXA/TRE/...):** team views that **pull rosters** by filtering Rosters.
* **PlayerPool:** minimal list (Player Name, PDGA #) used by Discord bot for autocomplete.
* **WebhookLog:** operational log of webhook receives + rebuild steps.

### B) Apps Script backend (the “orchestrator”)

* Time-based triggers for event refresh
* Web app endpoint `doPost(e)` that receives Discord transactions
* `rebuildRosters()` that recomputes Rosters from DraftBoard + Transactions ledger 

### C) Discord bot (Node.js)

* Slash commands: `/transaction` (ADD/DROP), `/trade` (writes 2 TRADE rows)
* Player autocomplete powered by **PlayerPool CSV**
* Posts transaction payloads to Apps Script web app endpoint

### D) External sources

* **DiscGolfScene registration pages** (HTML scraped by Apps Script)
* PDGA player links used to extract PDGA IDs from the registration HTML

---

## 1) Event flow (registration checkmarks)

**Goal:** populate ✅ / — in each event column on MPO and FPO.

**Flow**

1. **Config tab** provides rows of:

   * `Event Header` (must match MPO/FPO column header text)
   * `Registration URL` (DiscGolfScene registration page)
2. Apps Script `updateAllEvents()` loops Config rows and calls:

   * `updateRegistrationColumnByPdga_("MPO", header, url)`
   * `updateRegistrationColumnByPdga_("FPO", header, url)` 
3. For each sheet:

   * detect the **event column** by header match
   * detect **PDGA # column** by one of: `PDGA #`, `Player PDGA #`, `PDGA`, `PDGA#`
   * fetch registration HTML from DiscGolfScene
   * regex-scan for `https://www.pdga.com/player/<id>`
   * write ✅ if the player’s PDGA ID is found; otherwise — (and — if PDGA is blank)
4. Results are logged back into Config columns D–F as a lightweight run log.

**Data keys**

* Primary join key: **PDGA #** (string)
* Column match key: **exact event header text**

---

## 2) Transaction flow (ADD / DROP / TRADE)

**Goal:** append a row (or two) to **Transactions**, then recompute Rosters so Ownership updates everywhere.

### 2A) Discord → Apps Script (ingress)

1. Discord user runs:

   * `/transaction team add_player drop_player notes`
   * `/trade team_a player_a team_b player_b notes`
2. Bot resolves **PDGA #** from the cached PlayerPool map:

   * `nameToPdga.get(playerName)`
3. Bot POSTs JSON to Apps Script Web App:

   * `secret`, `date`, `type`, `team`, `pdga`, `name`, `fromTeam`, `toTeam`, `notes` 

### 2B) Apps Script `doPost(e)` (validation + logging)

4. Apps Script:

   * acquires `LockService` lock (serializes concurrent requests)
   * validates `data.secret === TX_SECRET`
   * normalizes team names (canonical list + shorthand mapping)
5. Writes to **WebhookLog**:

   * `RECEIVED` row with payload summary
6. Appends row to **Transactions**:

   * `[date, type, team, pdga, name, fromTeam, toTeam, notes]`
7. Logs:

   * `BEFORE_REBUILD`
8. Calls `rebuildRosters()`
9. Logs:

   * `AFTER_REBUILD`

### 2C) TRADE specifics

* `/trade` produces **two TRADE rows**:

  * Team A player moves A → B
  * Team B player moves B → A
* Apps Script applies the ledger in order, so the final state is “newest wins”.

**Data keys**

* Primary key for roster state: **PDGA #**
* Team identity: canonical team names (normalized)

---

## 3) Roster rebuild flow (DraftBoard + Transactions → Rosters)

**Goal:** produce a full “current state” table of ownership by PDGA.

**Flow inside `rebuildRosters()`**

1. Opens the spreadsheet by ID (important for web app context) 
2. Reads MPO and FPO master tabs to build two lookup maps:

   * `Name → PDGA`
   * `PDGA → Name`
3. Reads DraftBoard baseline:

   * expects headers: `Team`, `Division`, `Player Name`
   * optional: `Player PDGA #` (preferred if present)
4. Builds an in-memory `current` map keyed by PDGA:

   * `pdga -> { team, name, division, source: "Draft" }`
5. Reads Transactions ledger and applies **oldest → newest**:

   * **ADD:** set team to `toTeam || team`
   * **DROP:** set team to `Free Agents` (if current team matches expected `fromTeam || team`)
   * **TRADE:** set team to `toTeam`
6. Writes Rosters from the map:

   * Header: `Team | Player PDGA # | Player Name | Division | Source | Last Updated`
   * Sorts output by `Team + Player Name`
   * **Clears Rosters contents first**, then writes the new table

**Important architecture note**

* This design makes **Rosters the computed “state table”**, and **Transactions the durable “event log”** (event-sourcing pattern).
* Many other parts of the sheet treat Rosters as the “current truth.”

---

## 4) Discord interaction flow (commands + autocomplete + receipts)

### 4A) Player autocomplete

1. On bot startup (and every 6 hours), bot fetches **PlayerPool CSV URL**
2. Bot parses CSV lines and builds:

   * `players = [{name, pdga}]`
   * `nameToPdga = Map(name → pdga)`
3. When user types a player option, Discord triggers `interaction.isAutocomplete()`
4. Bot returns up to 25 matches:

   * display: `Name (PDGA)`
   * value sent back: `Name`

### 4B) Command execution & receipts

5. `/transaction`

   * accepts add and/or drop
   * POSTs one payload per action (DROP and/or ADD)
   * posts a **public** receipt message in-channel
6. `/trade`

   * POSTs two TRADE payloads sequentially
   * posts a **public** receipt message in-channel
7. Errors:

   * If already replied/deferred publicly, bot follows up with **ephemeral** error message.

---

## 5) Ownership propagation (how “ownership” spreads everywhere)

This is the critical “data gravity” path in your system:

### 5A) Ownership column in MPO/FPO

* MPO/FPO have an **Ownership** column that is an array formula equivalent to:

**Ownership := XLOOKUP(PDGA#, Rosters!B:B, Rosters!A:A, "Free Agent")**

So:

1. **Rosters** is the authoritative lookup table
2. MPO/FPO “Ownership” updates automatically whenever Rosters changes
3. Anything else that depends on MPO/FPO ownership now updates

### 5B) Team pages / views

* Team tabs (SIR/EXA/…) are essentially:

  * filter Rosters by `Team = <this tab’s team name in B1>`
  * spill player names (and likely other derived details)
* So team rosters shown to users are:

  * **Team tabs ← Rosters**
  * (not directly from DraftBoard or Transactions)

### 5C) Downstream sheet behavior

Because Rosters is rewritten on rebuild:

* Any formula that references Rosters (lookups, filters, conditional formatting “owned vs free agent”) will recalc after rebuild.
* Your UI is effectively:

  * **Transactions (event log)** → **Rosters (state)** → **Ownership columns + Team tabs (presentation)**

---

## One-page mental model

* **Event refresh (scheduled/manual):**

  * Config → (scrape DGS) → MPO/FPO event columns (✅/—)

* **Roster state (on transaction):**

  * Discord command → Apps Script doPost → Transactions append → rebuildRosters →
  * Rosters rewritten → Ownership formula updates → Team views update

* **Keys:**

  * PDGA # = global unique player key
  * Team name normalization = consistency layer between Discord + Sheets

---

If you want, next step after this map is I can produce a **component diagram** (boxes/arrows) and a **tab dependency graph** (which tabs read which other tabs) so it’s easier to see exactly where fragile coupling lives—still without changing anything.
